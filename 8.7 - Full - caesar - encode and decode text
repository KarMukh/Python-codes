#### Here what we want to be able to do in this lesson is just to tidy up some of the loose ends, improve the user experience and fix some of the bugs that you may or may not be aware of. 
####TODO-1: Import and print the logo from art.py when the program starts. It is considered that our logo is perpared on anonther file with the name art.

logo = """           
 ,adPPYba, ,adPPYYba,  ,adPPYba, ,adPPYba, ,adPPYYba, 8b,dPPYba,  
a8"     "" ""     `Y8 a8P_____88 I8[    "" ""     `Y8 88P'   "Y8  
8b         ,adPPPPP88 8PP"""""""  `"Y8ba,  ,adPPPPP88 88          
"8a,   ,aa 88,    ,88 "8b,   ,aa aa    ]8I 88,    ,88 88          
 `"Ybbd8"' `"8bbdP"Y8  `"Ybbd8"' `"YbbdP"' `"8bbdP"Y8 88   
            88             88                                 
           ""             88                                 
                          88                                 
 ,adPPYba, 88 8b,dPPYba,  88,dPPYba,   ,adPPYba, 8b,dPPYba,  
a8"     "" 88 88P'    "8a 88P'    "8a a8P_____88 88P'   "Y8  
8b         88 88       d8 88       88 8PP""""""" 88          
"8a,   ,aa 88 88b,   ,a8" 88       88 "8b,   ,aa 88          
 `"Ybbd8"' 88 88`YbbdP"'  88       88  `"Ybbd8"' 88          
              88                                             
              88           
"""


#### TODO-2: is also very interesting. If the user enters a shift number that's actually really, really large like 100, then we're actually going to run out of letters in our alphabet, because we have 2 * 26 letters in our alphabet list.

#####TODO-3: What happens if the user enters a number/symbol/space? So we want to preserve the symbols, space, or number that they typed in and we're only going to use our cipher on the rest of the message, so only the alphabetical letters. And everything else we're going to leave the same (the end_text will keep the spaces where they were, keep the numbers where they were).

### #TODO-4: we're going to figure out how to ask the user if they want to restart the cipher program?
####e.g. Type 'yes' if you want to go again. Otherwise type 'no'.


##########################################
### Here starts our code:

alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

#### To encrypt a word or sentance of course we need the alphabet with its order.
#### Actually we have two alphabets here (duplicated), but the discribtion marked by *** we can find at the end of this code. 
#### By the way, except encoding with a certain amount of movment (shifting) we can try to do it by changing the letters order, or even both with changing the letters order and then shifting them in that order.

### Here we create a function called 'caesar' that takes the text, shift and direction as inputs.
#### First I'm going to call the first parameter start_text because we could be passed the plain_text or the cipher_text as it was in the previous one. The second parameter remains as it was, and the third parameter, in order to differentiate it from the direction used in our code, I'm gonna call cipher_direction. 

def caesar(start_text, shift_amount, cipher_direction):

  #### Then after a colon, we're done with defining our function and we can start figuring out how we can combine these two functions together: encrypt and decrypt functions. We know in both of them. 
  ##### We need some sort of way of storing a piece of text which starts out as empty and then it ends up being the entire encrypted or decrypted text. So we can create a new variable called end_text (see below) to contrast with a start_text.
  
  end_text = ""
  
  ### Then when we're encrypting text, we're shifting that position upwards by adding the shift amount. But on the other hand, when we're decrypting, we're subtracting the shift amount from the position.
  #### So one way of doing this is, of course, by using an if statement. So you could check if the cipher_direction was equal to encode. Well then in this case, the new position is going to be equal to position plus the shift_amount. And then you could do the else statement.

  #### The easier way of doing this is: we can just check for if the cipher direction was decode, in this case, we take the shift amount and we multiply it by minus one (see below).

  if cipher_direction == "decode":
    shift_amount *= -1
          ### Same as shift_amount = shift_amount * -1
          
  ### We have to loop through this text that we get passed over. So let's create a for loop; for each character in the start_text, we're going to do something with each those chars. Namely, we're going to get hold of the position of the letter in the alphabet.
  
  for char in start_text:
    #TODO-3: What happens if the user enters a number/symbol/space?
    #Can you fix the code to keep the number/symbol/space when the text is encoded/decoded?
    #e.g. start_text = "meet me at 3"
    #end_text = "•••• •• •• 3"
    
    #### So here we want to be able to allow any number, symbol or space, basically anything that's not within the alphabet to go through and end up in the end_text. But if it is one of the letters inside this list alphabet, then and only then do we actually want to do the shifting and encoding. 
    ###In order to achieve this, we should probably use an if statement.
    ### So notice how I've changed the for loop to instead of writing: ### for letter in start_text ###which kind of assumes that everything in the start_text is a letter, to char which stands for character instead because a character could be a number, could be a symbol, could be a letter, could be space.
    #### And then once we get hold of the char or the character, we're going to check to see if the char is in the alphabet. So if it is indeed one of these letters and not some other random character, well then and only then do we actually want this code to be executed.
    
    if char in alphabet:
      position = alphabet.index(char)
      #### And then we can take each of these characters (from the for loop) and work out its letter's position in the alphabet list above here.
      #### And we can do that by using the index method.
      #### So we can tap into a list (alphabet in our case), write .index, and then put in the value (letter in our case) that we want to get the index for and we should be able to get that as the result (position in our case).
      
      new_position = position + shift_amount
      ### Then we're going to calculate the new position. Now the new position is just going to be the previous position, which is going to be a number, and then plus the shift amount.
      
      end_text += alphabet[new_position]
          ### Now all we have to do is to tap into our end_text and to add to it by getting hold of the letter at the new position in the alphabet.
          
    else:
      end_text += char
      ### Here we want to say: and if our char not inside the alphabet, so else, then, in this case, we actually want to make the end_text append the actual character, so without any modification.
      
  print(f"Here's the {cipher_direction}d result: {end_text}")
      #### Here we can see how we can change the to be printed text to be dynamic, so depending on the cipher direction (instead of using print(f"The encoded text is {cipher_text}") or print(f"The decoded text is {plain_text}") we can use {cipther_directio}d as we remember when the user is typing in the direction, they're typing in either encode or decode, and the result will be encoded or decoded), and then the last part is easy because we can just replace it with the end_text.

#TODO-1: Import and print the logo from art.py when the program starts.
from art import logo
print(logo)
### And if we want to be able to use the logo variable inside the art file, this one, then we can also simply just write from art import logo.

#TODO-4: Can you figure out a way to ask the user if they want to restart the cipher program?
#e.g. Type 'yes' if you want to go again. Otherwise type 'no'.
#If they type 'yes' then ask them for the direction/text/shift again and call the caesar() function again?
#Hint: Try creating a while loop that continues to execute the program if the user types 'yes'.

#### So at the moment, the part of our code that actually needs to be repeated if the user wanted to restart it is actually just 5 code lines: direction, text, shift = int..., shift = shift % 26 and caesar (see all of them below).
### Here we can go ahead and indent this and put it inside a while loop.
### What are we going to check to make sure that our loop continues?
### Well, we could create a flag called should_continue and we start this out to be true.
### And then while this is still true, we continue to keep looping through this so that the user gets to input a new direction, new text, new shift and call the Caesar cipher on that again.


### When should we stop it though? Well, if at the end of deciphering or encoding their message, we ask them a question, something like type yes if you want to go again or type no if you don't want to, we could put that inside an input.

###  And we can save their answer inside a variable called restart (see below).

####So then we can use an if statement to check well, if the results is equal to no, so when they actually want to stop and they want to exit the while loop, well, at this point we can switch that should_continue to false. And once that's done, then this means that our while loop, when it checks it, this is going to be false and it will no longer continue. Just as a final touch, we can even tell the user goodbye so that they know that the program has ended.

should_end = False
while not should_end:

    #### Now below we've also got three inputs which the users are going to type in.
    
  direction = input("Type 'encode' to encrypt, type 'decode' to decrypt:\n")
  text = input("Type your message:\n").lower()
  shift = int(input("Type the shift number:\n"))
  
  #TODO-2: What if the user enters a shift that is greater than the number of letters in the alphabet?
  #Try running the program and entering a shift number of 45.
  #Add some code so that the program continues to work even if the user enters a shift number greater than 26. 
  #Hint: Think about how you can use the modulus (%).

  #### What happens when we type a message and we put a shift that's really large (let say 83). We can see we get an index out of range error because there is no letter at position 83 from the alphabet.
  ### Here using the modulus (%) we can get the reminder of smth. And that remainder allows us to shift the shift_number that's entered into something that fits in with the number of letters of the alphabet that we have in here.
  ### So then our code that we would have below is to modify the shift by taking the shift that the user entered up here and then using the modulus to divide it by 26 as many times as needed until we get the remainder.
  shift = shift % 26

  caesar(start_text=text, shift_amount=shift, cipher_direction=direction)
      ### Here we can simply just call the Caesar function passing over the start_text as the text the user inputted, the shift_amount as the shift that they inputted, and finally, the cypher_direction as the direction that they inputted.
  
  restart = input("Type 'yes' if you want to go again. Otherwise type 'no'.\n")
  if restart == "no":
    should_end = True
    print("Goodbye")
  
  
  
##########################################################
##########################################################

## The result on console gonna be e.g.

,adPPYba, ,adPPYYba,  ,adPPYba, ,adPPYba, ,adPPYYba, 8b,dPPYba,  
a8"     "" ""     `Y8 a8P_____88 I8[    "" ""     `Y8 88P'   "Y8  
8b         ,adPPPPP88 8PP"  `"Y8ba,  ,adPPPPP88 88          
"8a,   ,aa 88,    ,88 "8b,   ,aa aa    ]8I 88,    ,88 88          
 `"Ybbd8"' `"8bbdP"Y8  `"Ybbd8"' `"YbbdP"' `"8bbdP"Y8 88   
            88             88                                 
           ""             88                                 
                          88                                 
 ,adPPYba, 88 8b,dPPYba,  88,dPPYba,   ,adPPYba, 8b,dPPYba,  
a8"     "" 88 88P'    "8a 88P'    "8a a8P_____88 88P'   "Y8  
8b         88 88       d8 88       88 8PP" 88          
"8a,   ,aa 88 88b,   ,a8" 88       88 "8b,   ,aa 88          
 `"Ybbd8"' 88 88`YbbdP"'  88       88  `"Ybbd8"' 88          
              88                                             
              88           

Type 'encode' to encrypt, type 'decode' to decrypt:
encode
Type your message:
hello **+
Type the shift number:
5
Here's the encoded result: mjqqt **+
Type 'yes' if you want to go again. Otherwise type 'no'.
yes
Type 'encode' to encrypt, type 'decode' to decrypt:
decode
Type your message:
mjqqt
Type the shift number:
5
Here's the decoded result: hello **+
Type 'yes' if you want to go again. Otherwise type 'no'.
no
Goodbye
 
