################### Scope ####################

enemies = 1

def increase_enemies():
  enemies = 2
    ### Here we may think that we're tapping into this variable and setting it to two. But in fact, we're actually creating a completely new variable that's entirely separate from the enemies = 1.
  print(f"enemies inside function: {enemies}")
  #### this print function gonna print 2, because Local scope exists within functions.
  
increase_enemies()
print(f"enemies outside function: {enemies}")
#### this print function gonna print 1, because Local scope exists within functions.
### So this has a global scope. It's available anywhere within our file because it was defined at the top level of the file. 
### Global variables are available within functions, no matter how deep it gets nested and it's also available outside of functions.



#### The result on console after running this code gonna be:
### enemies inside function: 2
#### enemies outside function: 1


############ Buuut blocks like if, while, for, all of these blocks of code with colons and indentation, they don't count as creating a local scope.

#### A variable within a functionis only available within that function.
# game_level = 3
# enemies = [A, B, C]
# if enemies > 3:
#   new_enemy = enemies[1]
# print(new_enemy)

### The result for this function gonns be: B
